const { ethers } = require('ethers');const walletManager = require('./wallet');const gasManager = require('./gasManager');const mempool = require('./mempool');const logger = require('../utils/logger');const scanner = require('./scanner'); const dexConfigs = require('../config/dexes');const networks = require('../config/networks');const erc20Abi = require('../abis/erc20.json');const routerAbi = require('../abis/router.json');class Executor {  constructor() {    this.flashContractAddress = {};  }  /**   * Ch·ªët ch·∫∑n an to√†n ƒë·ªÉ tr√°nh l·ªói ENS   * N·∫øu ƒë·ªãa ch·ªâ sai, n√≥ s·∫Ω b√°o r√µ label (v√≠ d·ª•: Router_Buy) ƒë·ªÉ b·∫°n check config   */  _createContract(address, abi, wallet, label) {    if (!address || address === "0x..." || !ethers.utils.isAddress(address)) {      const msg = `üî¥ L·ªñI C·∫§U H√åNH [${label}]: ƒê·ªãa ch·ªâ kh√¥ng h·ª£p l·ªá ho·∫∑c b·ªã tr·ªëng (Gi√° tr·ªã: "${address}")`;      logger.error(msg);      throw new Error(msg);    }    // ƒê·∫£m b·∫£o c√≥ provider/wallet tr∆∞·ªõc khi init    if (!wallet) {      throw new Error(`üî¥ L·ªñI [${label}]: Wallet/Provider ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o.`);    }    return new ethers.Contract(address, abi, wallet);  }  setFlashContractAddress(network, address) {    if (!ethers.utils.isAddress(address)) {        logger.error(`‚ùå Flash address kh√¥ng h·ª£p l·ªá cho ${network}: ${address}`);        return;    }    this.flashContractAddress[network] = address;    logger.info(`‚öôÔ∏è H·ªá th·ªëng: Flash contract s·∫µn s√†ng [${network}]: ${address}`);  }  async autoApprove(network, dexName, tokenAddress) {    try {      const wallet = walletManager.getWallet(network);      const dex = dexConfigs[network]?.find(d => d.name === dexName);            const tokenContract = this._createContract(tokenAddress, erc20Abi, wallet, "Token_Approve");            if (!dex || !dex.router) throw new Error(`Dex ${dexName} router not found`);            const allowance = await tokenContract.allowance(wallet.address, dex.router);      if (allowance.gt(ethers.constants.MaxUint256.div(2))) return true;      const gasPrice = await gasManager.getOptimalGasPrice(network);      const txData = await tokenContract.populateTransaction.approve(dex.router, ethers.constants.MaxUint256);            const txResponse = await mempool.sendTransaction(network, {        ...txData,        gasPrice: gasPrice.mul(120).div(100)      });            await txResponse.wait();      return true;    } catch (error) {      logger.error(`‚ùå L·ªói Auto-Approve: ${error.message}`);      return false;    }  }  async executeBuy(network, dexName, tokenAddress, amountIn, slippage = 15) {    try {      const wallet = walletManager.getWallet(network);      const dex = dexConfigs[network]?.find(d => d.name === dexName);            if (!dex) throw new Error(`Kh√¥ng t√¨m th·∫•y c·∫•u h√¨nh DEX cho ${dexName}`);      const router = this._createContract(dex.router, routerAbi, wallet, "Router_Buy");            // Ki·ªÉm tra an to√†n t·ª´ scanner      const safety = await scanner.verifyTokenSafety(network, dexName, tokenAddress);      if (!safety.isSafe) {          logger.error(`‚ö†Ô∏è B·ªé QUA: Token kh√¥ng an to√†n (${safety.reason})`);          return null;      }      const wNative = networks[network].wNative;      const amountInWei = ethers.utils.parseEther(amountIn.toString());      const deadline = Math.floor(Date.now() / 1000) + 120;      const path = [wNative, tokenAddress];      const amounts = await router.getAmountsOut(amountInWei, path);      const amountOutMin = amounts[1].mul(100 - slippage).div(100);      const txData = await router.populateTransaction.swapExactETHForTokensSupportingFeeOnTransferTokens(        amountOutMin,        path,        wallet.address,        deadline,        { value: amountInWei }      );      const gasPrice = await gasManager.getOptimalGasPrice(network);      const txResponse = await mempool.sendTransaction(network, {        ...txData,        gasPrice: gasPrice.mul(125).div(100),        gasLimit: 500000      });      return await txResponse.wait();    } catch (error) {      logger.error(`‚ùå Snipe th·∫•t b·∫°i: ${error.message}`);      return null;    }  }  async executeSell(network, dexName, tokenAddress, slippage = 20) {    try {      const wallet = walletManager.getWallet(network);      const dex = dexConfigs[network]?.find(d => d.name === dexName);            if (!dex) throw new Error(`Kh√¥ng t√¨m th·∫•y c·∫•u h√¨nh DEX cho ${dexName}`);      const router = this._createContract(dex.router, routerAbi, wallet, "Router_Sell");      const tokenContract = this._createContract(tokenAddress, erc20Abi, wallet, "Token_Sell");            const balance = await tokenContract.balanceOf(wallet.address);      if (balance.isZero()) {        logger.warn(`‚ö†Ô∏è S·ªë d∆∞ token b·∫±ng 0, h·ªßy l·ªánh b√°n.`);        return null;      }      const wNative = networks[network].wNative;      const path = [tokenAddress, wNative];      const deadline = Math.floor(Date.now() / 1000) + 120;            const amounts = await router.getAmountsOut(balance, path);      const amountOutMin = amounts[1].mul(100 - slippage).div(100);      const gasPrice = await gasManager.getOptimalGasPrice(network);      const txData = await router.populateTransaction.swapExactTokensForETHSupportingFeeOnTransferTokens(        balance,        amountOutMin,        path,        wallet.address,        deadline      );      const txResponse = await mempool.sendTransaction(network, {        ...txData,        gasPrice: gasPrice.mul(130).div(100),        gasLimit: 500000      });      return await txResponse.wait();    } catch (error) {      logger.error(`‚ùå L·ªói khi b√°n: ${error.message}`);      return null;    }  }  async executeFlashArbitrage(network, buyDex, sellDex, tokenAddress, amountInNative) {    try {      const wallet = walletManager.getWallet(network);      const flashAddr = this.flashContractAddress[network];            if (!flashAddr) throw new Error(`Ch∆∞a c√≥ Flash Contract cho m·∫°ng ${network}`);      const flashContract = this._createContract(flashAddr, [        "function executeArbitrage(address buyRouter, address sellRouter, address token, uint256 amount) external"      ], wallet, "Flash_Contract");      const amountWei = ethers.utils.parseEther(amountInNative.toString());      const txData = await flashContract.populateTransaction.executeArbitrage(        buyDex.router,        sellDex.router,        tokenAddress,        amountWei      );      const gasPrice = await gasManager.getOptimalGasPrice(network);      return await mempool.sendTransaction(network, {        ...txData,        gasPrice: gasPrice.mul(150).div(100),        gasLimit: 1200000      });    } catch (error) {      logger.error(`‚ùå Flash Arbitrage th·∫•t b·∫°i: ${error.message}`);      return null;    }  }}// Export m·ªôt instance duy nh·∫•t ƒë·ªÉ d√πng chung b·ªô nh·ªõ flashContractAddressmodule.exports = new Executor();